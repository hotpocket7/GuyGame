package game.level;

import com.jogamp.opengl.GL2;
import game.Game;
import game.entity.*;
import game.entity.boss.BossRobotnik;
import game.graphics.*;
import game.graphics.light.Light;
import game.level.block.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import game.math.Vec2d;
import game.sound.Song;
import org.json.*;

public class Level {

    public static Level hubLevel, jumpLevel;

    public static Level currentLevel;
    public static ArrayList<Level> levels = new ArrayList<>();

    public ArrayList<Block> blocks = new ArrayList<>();
    public ArrayList<Light> lights = new ArrayList<>();
    public ArrayList<Entity> entities = new ArrayList<>();

    public HashMap<String, Entity> entityMap = new HashMap<>();

    public Vec2d spawn = new Vec2d();

    private SpriteSheet background;

    public Song song;

    public Color4f ambientColor = new Color4f();
    private int lightBlendFunc;

    static {
        hubLevel = new Level("/maps/hub.json", SpriteSheet.levelBG1, new Color4f(0x1b/255f, 0x1b/255f, 0x25/255f, 1),
                   Song.hubSong);
        hubLevel.setLightBlendFunc(1);

        jumpLevel = new Level("/maps/jump.json", SpriteSheet.levelBG2, new Color4f(.8f, .8f, .8f, 1),
                Song.jumpAreaSong) {
            public void create() {
                BlockSave bossSave = (BlockSave) entityMap.get("bossSave");
                bossSave.addEvent("onSave", (e) -> {
                    BlockSave b = (BlockSave) e;
                    b.acceleration.y = 1;
                    song.pause();
                    Song.boss1.stop();
                    Song.boss1.play(true, Song.boss1.getMaxVolume());
                    addEntity(new BossRobotnik.Builder().position(5888, 1440).build());
                });
            }
        };
        jumpLevel.setLightBlendFunc(0);

        setLevel(jumpLevel);
    }

    public int width, height; // in pixels

    public Level(String path, SpriteSheet background, Color4f ambientColor, Song song){
        this.ambientColor.setEqual(ambientColor);
        this.background = background;
        try {
            loadLevelFromFile(path);
        } catch (JSONException | IOException e) {
            e.printStackTrace();
        }

        this.song = song;

        create();
        levels.add(this);
    }

    public void create(){}

    protected void loadLevelFromFile(String path) throws IOException, JSONException {
        //Levels are stored in JSON files generated by Tiled
        new LevelLoader(path, this).load();
    }

    public void update() {
        blocks.stream().filter(block -> block.active && (block.isOnScreen() || block.updateOffScreen()))
                .forEach(Block::update);
        entities.stream().filter(entity -> entity.active && (entity.isOnScreen() || entity.updateOffScreen()))
                .forEach(Entity::update);

        entities.stream().filter(e -> e.isCollider() && e.isOnScreen()).forEach(entity -> {
            entity.pollCollisions(entities);
            entity.pollCollisions(blocks);
        });

        Iterator<Block> blockIterator = blocks.iterator();
        Iterator<Entity> entityIterator = entities.iterator();

        while(blockIterator.hasNext()) {
            Block currentBlock = blockIterator.next();
            if(currentBlock.isDestroyed())
                blockIterator.remove();
        }

        while(entityIterator.hasNext()) {
            Entity currentEntity = entityIterator.next();
            if(currentEntity.isDestroyed())
                entityIterator.remove();
        }
    }

    public void render(GL2 gl) {
        Vec2d camera = Game.screen.getCamera();

        gl.glLoadIdentity();
        gl.glTranslated(-camera.x, camera.y, 0);

        background.renderSprite(0, camera, new Vec2d(0, 0), 0, 0, false, false, gl);

        blocks.stream().filter(b -> b.active && b.isOnScreen()).forEach(b -> b.render(gl));
        entities.stream().filter(e -> e.active && !e.renderInFront && e.isOnScreen()).forEach(e -> e.render(gl));

        Game.screen.getPlayer().render(gl);

        if(lights.size() > 0) {
            //Lights are rendered to a light map FBO, which is then blended with the fully lit scene by multiplying
            //the colors
            prepareLightMap(gl);
            renderLightMap(gl);
        }

        entities.stream().filter(e -> e.renderInFront && e.isOnScreen()).forEach(e -> e.render(gl));
    }

    private void prepareLightMap(GL2 gl) {
//      gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER, Game.scene.getLightMapFbo()[0]);
//      gl.glLoadIdentity();
        FrameBuffer.lightMap.bind(gl);

        gl.glEnable(GL2.GL_BLEND);
        gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA);
        gl.glClearColor(ambientColor.r, ambientColor.g, ambientColor.b, 1);
//      gl.glClearColor(1, 0, 0, 1);
        gl.glClear(GL2.GL_COLOR_BUFFER_BIT);

        lights.forEach(l -> l.render(gl));

        gl.glDisable(GL2.GL_BLEND);

        FrameBuffer.unbindCurrentFramebuffer(gl);
    }

    private void renderLightMap(GL2 gl) {
        float w = Game.WIDTH;
        float h = Game.HEIGHT;
        float x = 0;
        float y = 0;
        gl.glLoadIdentity();

//      gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER, 0);
//      gl.glEnable(GL2.GL_TEXTURE_2D);
//      gl.glBindTexture(GL2.GL_TEXTURE_2D, Game.scene.getLightMapTexture()[0]);

        FrameBuffer.lightMap.bindTexture(gl);

        gl.glEnable(GL2.GL_BLEND);
        switch(lightBlendFunc) {
            case 0:
                gl.glBlendFunc(GL2.GL_DST_COLOR, GL2.GL_ZERO);
                break;
            case 1:
                gl.glBlendFunc(GL2.GL_DST_COLOR, GL2.GL_SRC_COLOR);
                break;
            default:
                gl.glBlendFunc(GL2.GL_SRC_ALPHA, GL2.GL_ONE_MINUS_SRC_ALPHA);
        }
        gl.glBegin(GL2.GL_QUADS);
            gl.glColor4f(1, 1, 1, 1);

            gl.glTexCoord2f(0, 1);
            gl.glVertex2f(x, y);

            gl.glTexCoord2f(0, 0);
            gl.glVertex2f(x, y + h);

            gl.glTexCoord2f(1, 0);
            gl.glVertex2f(x + w, y + h);

            gl.glTexCoord2f(1, 1);
            gl.glVertex2f(x+w, y);
        gl.glEnd();
        gl.glDisable(GL2.GL_BLEND);
        FrameBuffer.lightMap.unbindTexture(gl);
//      gl.glDisable(GL2.GL_TEXTURE_2D);
    }

    public synchronized void restart() {
        Game.screen.getPlayer().active = true;
        Game.screen.getPlayer().setPos(spawn);
        Game.screen.getPlayer().setVel(new Vec2d(0, 0));
        Game.screen.getPlayer().state = Player.State.AIRBORNE;
        Game.screen.getPlayer().jumpsUsed = 1;

        blocks.stream().filter(Block::isTemporary).forEach(Block::destroy);
        entities.stream().filter(Entity::isTemporary).forEach(Entity::destroy);

        blocks.forEach(Block::respawn);
        entities.forEach(Entity::respawn);

        Song.pauseAll();
        song.resume();
        song.setVolume(song.getMaxVolume());
    }

    public void addEntity(Entity entity) {
        if(entity instanceof Block) {
            blocks.add((Block) entity);
            return;
        }
        entities.add(entity);
//      for(Layer layer : layers) {
//          if(entity.getSprite() != null && entity.getSprite().getSpriteSheet() == layer.spriteSheet) {
//              layer.entities.add(entity);
//          }
//      }
    }


    public void removeEntity(Entity entity) {
        if(blocks.contains(entity))
            blocks.remove(entity);
        entities.remove(entity);
    }

    public void addLight(Light light) {
        lights.add(light);
    }

    public static Level getCurrentLevel() {
        return currentLevel;
    }

    public static void setLevel(int lvl) {
        Level level = levels.get(lvl);
        setLevel(level);
    }

    public static void setLevel(Level level) {
//      if(currentLevel != null && currentLevel.music != null && currentLevel.music.playing())
//          currentLevel.music.stop();

        currentLevel = level;
        Game.screen.getPlayer().setPos(level.spawn);

//      level.music.play(true, level.musicVolume);
    }

    public void setLightBlendFunc(int id) {
        lightBlendFunc = id;
    }

    public void setSpawn(Vec2d spawn) {
        this.spawn.setEqual(spawn);
    }
}
